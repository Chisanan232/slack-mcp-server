---
id: security
title: Authentication Requirements
sidebar_position: 3
---

# Authentication Requirements

This page outlines the authentication requirements for webhook API endpoints. For detailed security architecture and implementation details, see [Webhook Server Architecture](/dev/next/architecture/webhook-server-architecture#security-architecture).

## Required Environment Variables

The following environment variables must be set for proper authentication:

| Variable | Required | Description |
|----------|----------|-------------|
| `SLACK_SIGNING_SECRET` | ✅ Yes | App signing secret for request verification |
| `SLACK_BOT_TOKEN` | ✅ Yes | Bot token for Slack API operations |
| `TIMESTAMP_TOLERANCE` | ❌ No | Request timestamp tolerance in seconds (default: 300) |

## Required Request Headers

All webhook requests must include the following headers for authentication:

| Header | Format | Description |
|--------|--------|-------------|
| `X-Slack-Signature` | `v0=<hex_signature>` | HMAC-SHA256 signature of the request |
| `X-Slack-Request-Timestamp` | Unix timestamp | When the request was generated |
| `Content-Type` | `application/json` | Request content type |

### Example Headers

```http
X-Slack-Signature: v0=a2114d57b48eac39b9ad189dd8316235a7b4a8d21a10bd27519666489c69b503
X-Slack-Request-Timestamp: 1531420618
Content-Type: application/json
```

## Authentication Setup

### 1. Get Slack Credentials

**Signing Secret**: Slack App → Basic Information → App Credentials → Signing Secret  
**Bot Token**: Slack App → OAuth & Permissions → Bot User OAuth Token

### 2. Set Environment Variables

```bash
export SLACK_SIGNING_SECRET="your_32_character_signing_secret_here"
export SLACK_BOT_TOKEN="xoxb-1234567890123-1234567890123-abcdefghijklmnopqrstuvwx"
```

### 3. Optional Configuration

```bash
export SLACK_EVENTS_TOPIC="custom_slack_events_topic"  # Default: "slack_events"
export TIMESTAMP_TOLERANCE="300"                       # Default: 300 seconds
```

## Response Codes

| Status | Description |
|--------|-------------|
| `200 OK` | Request authenticated successfully |
| `401 Unauthorized` | Invalid signature or missing credentials |
| `400 Bad Request` | Malformed headers or timestamp too old |

## Quick Setup

Create a `.env` file with your credentials:

```bash
# Required
SLACK_SIGNING_SECRET=your_signing_secret_here
SLACK_BOT_TOKEN=xoxb-your-bot-token-here

# Optional
SLACK_EVENTS_TOPIC=production_slack_events
TIMESTAMP_TOLERANCE=300
```

---

**For detailed security architecture and implementation details, see [Webhook Server Architecture](/dev/next/architecture/webhook-server-architecture#security-architecture).**
```

#### Loading Environment Files

```bash
# Default: loads .env from current directory
python -m slack_mcp.webhook

# Custom environment file
python -m slack_mcp.webhook --env-file /path/to/.env.production

# Disable environment file loading
python -m slack_mcp.webhook --no-env-file
```

## Security Best Practices

### 1. Secret Management

#### ❌ Insecure Approaches
```bash
# Never hardcode secrets
SLACK_SIGNING_SECRET="hardcoded_secret_in_code"

# Never commit secrets to version control
git add .env  # Contains production secrets

# Never log secrets
print(f"Using secret: {signing_secret}")
```

#### ✅ Secure Approaches
```bash
# Use environment variables
export SLACK_SIGNING_SECRET=$(cat /etc/secrets/slack_signing_secret)

# Use container secrets (Kubernetes)
kubectl create secret generic slack-secrets \
  --from-literal=signing-secret="your_secret_here"

# Use cloud secret management (AWS Secrets Manager, etc.)
aws secretsmanager get-secret-value --secret-id slack/webhook/signing-secret
```

### 2. Network Security

#### Production Deployment
```bash
# Always use HTTPS in production
https://your-domain.com/slack/events

# Consider IP whitelisting (Slack IP ranges)
# https://api.slack.com/docs/verifying-requests-from-slack#ip_whitelisting
```

#### Local Development
```bash
# Use ngrok for secure local testing
ngrok http 3000
# Results in: https://abc123.ngrok.io/slack/events
```

### 3. Error Handling

The server implements secure error handling:

```python
# Security-focused error responses
if not await verify_slack_request(request):
    _LOG.warning("Invalid Slack request signature")
    raise HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Invalid request signature"
    )
```

**Security Benefits**:
- **Minimal Information Disclosure**: Generic error messages
- **Audit Trail**: All failed attempts logged
- **Rate Limiting**: Prevents brute force attacks

### 4. Logging Security

#### Secure Logging Practices
```python
# ✅ Log security events without exposing secrets
_LOG.info("Handling URL verification challenge")
_LOG.warning("Invalid Slack request signature")
_LOG.error("SLACK_SIGNING_SECRET not set in environment")

# ❌ Never log sensitive information
_LOG.debug(f"Signing secret: {signing_secret}")  # NEVER DO THIS
_LOG.info(f"Request body: {body}")  # May contain sensitive data
```

#### Log Monitoring
Monitor these log patterns for security events:

```bash
# Failed signature verifications (potential attacks)
grep "Invalid Slack request signature" /var/log/webhook.log

# Missing configuration (deployment issues)
grep "SLACK_SIGNING_SECRET not set" /var/log/webhook.log

# Successful verifications (normal operation)
grep "Received Slack event" /var/log/webhook.log
```

## Advanced Security Configuration

### 1. Custom Signature Verification

For advanced use cases, you can implement custom signature verification:

```python
import hmac
import hashlib
import time

def custom_verify_signature(
    signing_secret: str,
    timestamp: str,
    body: str,
    signature: str,
    max_age_seconds: int = 300  # 5 minutes
) -> bool:
    """Custom signature verification with additional security checks."""
    
    # Check timestamp age (prevent replay attacks)
    current_time = int(time.time())
    request_time = int(timestamp)
    
    if abs(current_time - request_time) > max_age_seconds:
        return False
    
    # Calculate expected signature
    basestring = f"v0:{timestamp}:{body}"
    expected_signature = f"v0={hmac.new(
        signing_secret.encode(),
        basestring.encode(),
        hashlib.sha256
    ).hexdigest()}"
    
    # Compare signatures securely
    return hmac.compare_digest(expected_signature, signature)
```

### 2. Rate Limiting

Implement rate limiting for additional security:

```python
from fastapi import Request
from slowapi import Limiter, _rate_limit_exceeded_handler
from slowapi.util import get_remote_address
from slowapi.errors import RateLimitExceeded

limiter = Limiter(key_func=get_remote_address)

@app.post("/slack/events")
@limiter.limit("100/minute")  # Limit to 100 requests per minute per IP
async def slack_events(request: Request):
    # Your event handling logic here
    pass
```

### 3. IP Whitelisting

For maximum security, whitelist Slack's IP ranges:

```python
SLACK_IP_RANGES = [
    "54.230.0.0/16",
    "54.239.128.0/18",
    # Add other Slack IP ranges
]

def is_slack_ip(client_ip: str) -> bool:
    """Check if the client IP is from Slack."""
    import ipaddress
    
    client_addr = ipaddress.ip_address(client_ip)
    
    for ip_range in SLACK_IP_RANGES:
        if client_addr in ipaddress.ip_network(ip_range):
            return True
    
    return False

@app.middleware("http")
async def ip_whitelist_middleware(request: Request, call_next):
    client_ip = request.client.host
    
    if not is_slack_ip(client_ip):
        return JSONResponse(
            status_code=403,
            content={"detail": "Access denied"}
        )
    
    response = await call_next(request)
    return response
```

## Security Testing

### 1. Signature Verification Testing

Test signature verification with invalid signatures:

```bash
# Test with invalid signature
curl -X POST http://localhost:3000/slack/events \
  -H "Content-Type: application/json" \
  -H "X-Slack-Signature: v0=invalid_signature" \
  -H "X-Slack-Request-Timestamp: $(date +%s)" \
  -d '{"type": "url_verification", "challenge": "test"}'

# Expected: 401 Unauthorized
```

### 2. Timestamp Validation Testing

Test with old timestamps:

```bash
# Test with old timestamp (over 5 minutes old)
OLD_TIMESTAMP=$(($(date +%s) - 400))
curl -X POST http://localhost:3000/slack/events \
  -H "Content-Type: application/json" \
  -H "X-Slack-Signature: v0=signature" \
  -H "X-Slack-Request-Timestamp: $OLD_TIMESTAMP" \
  -d '{"type": "url_verification", "challenge": "test"}'

# Expected: 401 Unauthorized (depending on implementation)
```

### 3. Automated Security Testing

```python
import pytest
from fastapi.testclient import TestClient
from slack_mcp.webhook.server import create_slack_app

@pytest.fixture
def client():
    app = create_slack_app()
    return TestClient(app)

def test_invalid_signature_rejected(client):
    """Test that requests with invalid signatures are rejected."""
    response = client.post(
        "/slack/events",
        json={"type": "url_verification", "challenge": "test"},
        headers={
            "X-Slack-Signature": "v0=invalid",
            "X-Slack-Request-Timestamp": str(int(time.time()))
        }
    )
    
    assert response.status_code == 401

def test_missing_signature_rejected(client):
    """Test that requests without signatures are rejected."""
    response = client.post(
        "/slack/events",
        json={"type": "url_verification", "challenge": "test"}
    )
    
    assert response.status_code == 401
```

## Compliance and Auditing

### 1. Security Audit Checklist

- ✅ **Signature Verification**: All requests verified with HMAC-SHA256
- ✅ **Secret Management**: Secrets loaded from environment, not hardcoded
- ✅ **HTTPS**: Production deployment uses HTTPS
- ✅ **Error Handling**: Security errors logged without exposing secrets
- ✅ **Timestamp Validation**: Old requests rejected to prevent replay attacks
- ✅ **Input Validation**: All payloads validated with Pydantic models

### 2. Security Monitoring

Monitor these metrics for security insights:

```python
# Security metrics to track
security_metrics = {
    "signature_verification_failures": 0,
    "missing_signatures": 0,
    "timestamp_validation_failures": 0,
    "successful_authentications": 0,
    "total_requests": 0
}
```

### 3. Incident Response

In case of security incidents:

1. **Immediate**: Rotate signing secret and bot token
2. **Analysis**: Review logs for attack patterns
3. **Mitigation**: Implement additional security measures if needed
4. **Documentation**: Update security procedures based on findings

## Security FAQ

**Q: Can I disable signature verification for development?**
A: Not recommended. Use ngrok for local development instead, which maintains security while allowing local testing.

**Q: How often should I rotate secrets?**
A: Rotate immediately if compromised, otherwise follow your organization's security policies (typically 90-180 days).

**Q: What happens if my signing secret is compromised?**
A: Regenerate it immediately in your Slack app settings and update all deployments. All existing requests will start failing until updated.

**Q: Can I use the same signing secret for multiple environments?**
A: Not recommended. Use separate Slack apps and signing secrets for development, staging, and production.

**Q: Is the legacy token field in requests used for verification?**
A: No, the `token` field in request bodies is deprecated. Only signature verification is used for authentication.
