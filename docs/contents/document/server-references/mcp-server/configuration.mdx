---
id: mcp-server-configuration
title: Configuration
sidebar_position: 2
---

```mdx-code-block
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
```

# MCP Server Configuration

The MCP (Model Context Protocol) server provides flexible configuration options through environment variables, CLI arguments, and configuration files. This guide covers all available configuration methods for both development and production deployments.

## Environment Variables

### Required Environment Variables

The MCP server requires the following environment variables to function properly:

```bash
# Slack authentication (required)
SLACK_BOT_TOKEN="xoxb-your-bot-token-here"
```

### Optional Environment Variables

```bash
# Alternative token variable (fallback)
SLACK_TOKEN="xoxb-your-bot-token-here"

# Additional Slack credentials (for advanced features)
SLACK_BOT_ID="your-slack-bot-id"
SLACK_USER_TOKEN="xoxp-your-user-token"  # For user-level operations
SLACK_SIGNING_SECRET="your-signing-secret"  # For webhook verification

# Test channel configuration (for development/testing)
SLACK_TEST_CHANNEL="#your-channel-name"
SLACK_TEST_CHANNEL_ID="C1234567890"

# Queue backend configuration
QUEUE_BACKEND="memory"            # memory | redis | kafka

# Redis backend settings (when QUEUE_BACKEND=redis)
REDIS_URL="redis://localhost:6379/0"

# Kafka backend settings (when QUEUE_BACKEND=kafka)
KAFKA_BOOTSTRAP="broker:9092"
```

## Environment File Configuration

### Basic .env File

Create a `.env` file in your project root for local development:

```bash
# .env
SLACK_BOT_TOKEN=xoxb-your-development-bot-token
QUEUE_BACKEND=memory
SLACK_TEST_CHANNEL=#general
```

### Development Environment (.env.development)

```bash
# .env.development
# Slack credentials
SLACK_BOT_ID=B1234567890
SLACK_BOT_TOKEN=xoxb-development-bot-token
SLACK_USER_TOKEN=xoxp-development-user-token
SLACK_SIGNING_SECRET=development-signing-secret

# Test configuration
SLACK_TEST_CHANNEL=#dev-testing
SLACK_TEST_CHANNEL_ID=C1234567890

# Queue backend (in-memory for development)
QUEUE_BACKEND=memory
```

### Production Environment (.env.production)

```bash
# .env.production
# Slack credentials
SLACK_BOT_ID=B9876543210
SLACK_BOT_TOKEN=xoxb-production-bot-token
SLACK_USER_TOKEN=xoxp-production-user-token
SLACK_SIGNING_SECRET=production-signing-secret

# Production channel configuration
SLACK_TEST_CHANNEL=#production-alerts
SLACK_TEST_CHANNEL_ID=C9876543210

# Queue backend (Redis for production)
QUEUE_BACKEND=redis
REDIS_URL=redis://prod-redis:6379/0
```

### Staging Environment (.env.staging)

```bash
# .env.staging
# Slack credentials
SLACK_BOT_ID=B5555555555
SLACK_BOT_TOKEN=xoxb-staging-bot-token
SLACK_USER_TOKEN=xoxp-staging-user-token
SLACK_SIGNING_SECRET=staging-signing-secret

# Staging channel configuration
SLACK_TEST_CHANNEL=#staging-tests
SLACK_TEST_CHANNEL_ID=C5555555555

# Queue backend (Redis for staging)
QUEUE_BACKEND=redis
REDIS_URL=redis://staging-redis:6379/1
```

## Queue Backend Configuration

### Memory Backend (Default)

In-memory queue for development and testing:

```bash
# .env
QUEUE_BACKEND=memory
```

**Use cases:**
- Local development
- Unit testing
- Single-process deployments

**Limitations:**
- Messages lost on restart
- Not suitable for production
- Single process only

### Redis Backend

Redis-based message queue for production deployments:

```bash
# .env
QUEUE_BACKEND=redis
REDIS_URL=redis://localhost:6379/0
```

**Use cases:**
- Production deployments
- Multi-process applications
- Distributed systems
- High availability setups

**Additional Redis Configuration:**
```bash
# Advanced Redis settings (if supported by redis backend plugin)
REDIS_MAX_CONNECTIONS=20
REDIS_RETRY_ON_TIMEOUT=true
REDIS_SOCKET_KEEPALIVE=true
```

### Kafka Backend

Apache Kafka for high-throughput message processing:

```bash
# .env
QUEUE_BACKEND=kafka
KAFKA_BOOTSTRAP=broker:9092
```

**Use cases:**
- High-throughput applications
- Event streaming
- Complex event processing
- Enterprise deployments

**Additional Kafka Configuration:**
```bash
# Advanced Kafka settings (if supported by kafka backend plugin)
KAFKA_TOPIC_PREFIX=slack_mcp
KAFKA_CONSUMER_GROUP=mcp_consumers
KAFKA_AUTO_OFFSET_RESET=earliest
```

## CLI Arguments

The MCP server accepts the following command-line arguments and can be executed using multiple methods:

### Execution Methods

<Tabs>
  <TabItem value="console" label="Console Script" default>
  ```bash
  slack-mcp-server [OPTIONS]
  ```
  </TabItem>
  <TabItem value="python" label="Python Module">
  ```bash
  python -m slack_mcp.mcp [OPTIONS]
  ```
  </TabItem>
  <TabItem value="poetry" label="Poetry">
  ```bash
  poetry run slack-mcp-server [OPTIONS]
  ```

  Or use poetry to run the module directly:

  ```bash
  poetry run python -m slack_mcp.mcp [OPTIONS]
  ```
  </TabItem>
  <TabItem value="uv" label="UV">
  ```bash
  uv run slack-mcp-server [OPTIONS]
  ```

  Or use uv to run the module directly:

  ```bash
  uv run python -m slack_mcp.mcp [OPTIONS]
  ```
  </TabItem>
</Tabs>

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `--transport` | `choice` | `"stdio"` | Transport type: stdio, sse, streamable-http |
| `--host` | `string` | `"127.0.0.1"` | Host interface to bind (HTTP transports only) |
| `--port` | `integer` | `3001` | Port number (HTTP transports only) |
| `--mount-path` | `string` | `"/mcp"` | Mount path for SSE transport |
| `--log-level` | `string` | `"INFO"` | Logging level |

**Note:** The MCP server configuration is primarily handled through environment variables. CLI arguments are mainly used for transport configuration when running in HTTP mode.

### CLI Examples

#### Basic Usage
<Tabs>
  <TabItem value="console" label="Console Script" default>
  ```bash
  slack-mcp-server  # Default: stdio transport
  slack-mcp-server --transport sse --host 0.0.0.0 --port 3001
  slack-mcp-server --transport sse --mount-path /api/mcp
  slack-mcp-server --log-level DEBUG
  ```
  </TabItem>
  <TabItem value="python" label="Python Module">
  ```bash
  python -m slack_mcp.mcp  # Default: stdio transport
  python -m slack_mcp.mcp --transport sse --host 0.0.0.0 --port 3001
  python -m slack_mcp.mcp --log-level DEBUG
  ```
  </TabItem>
  <TabItem value="poetry" label="Poetry">
  ```bash
  poetry run slack-mcp-server --transport sse --host 127.0.0.1 --port 3001
  poetry run python -m slack_mcp.mcp --log-level DEBUG
  ```
  </TabItem>
  <TabItem value="uv" label="UV">
  ```bash
  uv run slack-mcp-server --transport sse --host 0.0.0.0 --port 3001
  uv run python -m slack_mcp.mcp --log-level DEBUG
  ```
  </TabItem>
</Tabs>

#### Production Configuration
<Tabs>
  <TabItem value="console" label="Console Script" default>
  ```bash
  slack-mcp-server \
    --transport sse \
    --host 0.0.0.0 \
    --port 3001 \
    --log-level INFO
  ```
  </TabItem>
  <TabItem value="python" label="Python Module">
  ```bash
  python -m slack_mcp.mcp \
    --transport sse \
    --host 0.0.0.0 \
    --port 3001 \
    --log-level INFO
  ```
  </TabItem>
  <TabItem value="poetry" label="Poetry">
  ```bash
  poetry run slack-mcp-server \
    --transport sse \
    --host 0.0.0.0 \
    --port 3001 \
    --log-level INFO
  ```
  </TabItem>
  <TabItem value="uv" label="UV">
  ```bash
  uv run slack-mcp-server \
    --transport sse \
    --host 0.0.0.0 \
    --port 3001 \
    --log-level INFO
  ```
  </TabItem>
</Tabs>

## Configuration Validation

### Startup Validation

The MCP server performs validation on startup:

```python
# Token validation
if not slack_token:
    logger.error("SLACK_BOT_TOKEN not set in environment")
    raise ValueError("Missing required Slack bot token")

# Transport validation
if transport not in ['stdio', 'sse', 'streamable-http']:
    raise ValueError(f"Invalid transport: {transport}")

# Port validation (for HTTP transports)
if transport in ['sse', 'streamable-http']:
    if not (1 <= port <= 65535):
        raise ValueError(f"Invalid port number: {port}")
```

### Configuration Testing

Test your configuration before deployment:

```bash
# Test configuration loading
python -c "
import os
from dotenv import load_dotenv

# Load environment file
load_dotenv('.env.production')

# Check required variables
required_vars = ['SLACK_BOT_TOKEN']
for var in required_vars:
    if not os.environ.get(var):
        print(f'ERROR: {var} not set')
    else:
        print(f'✓ {var} configured')

# Check optional variables
optional_vars = ['QUEUE_BACKEND', 'REDIS_URL', 'KAFKA_BOOTSTRAP']
for var in optional_vars:
    value = os.environ.get(var)
    if value:
        print(f'✓ {var}={value}')
    else:
        print(f'- {var} using default')

# Test queue backend loading
try:
    from slack_mcp.backends.loader import load_backend
    backend = load_backend()
    print(f'✓ Queue backend loaded: {backend.__class__.__name__}')
except Exception as e:
    print(f'✗ Queue backend loading failed: {e}')
"
```

## Docker Configuration

### Dockerfile with Environment Variables

```dockerfile
FROM python:3.11-slim

WORKDIR /app
COPY requirements.txt .
RUN pip install -r requirements.txt

COPY . .

# Set default environment variables
ENV MCP_TRANSPORT=sse
ENV MCP_HOST=0.0.0.0
ENV MCP_PORT=3001
ENV LOG_LEVEL=INFO

# Expose port
EXPOSE 3001

CMD ["python", "-m", "slack_mcp.mcp", "--transport", "sse"]
```

### Docker Compose with Environment File

```yaml
version: '3.8'

services:
  mcp-server:
    build: .
    ports:
      - "3001:3001"
    env_file:
      - .env.production
    environment:
      - MCP_TRANSPORT=sse
      - MCP_HOST=0.0.0.0
      - MCP_PORT=3001
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3001/mcp"]
      interval: 30s
      timeout: 10s
      retries: 3
```

## Kubernetes Configuration

### ConfigMap for Environment Variables

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: mcp-server-config
data:
  MCP_TRANSPORT: "sse"
  MCP_HOST: "0.0.0.0"
  MCP_PORT: "3001"
  LOG_LEVEL: "INFO"
  MCP_TIMEOUT: "60"
  MCP_MAX_RETRIES: "5"
```

### Deployment with Configuration

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mcp-server
spec:
  replicas: 2
  selector:
    matchLabels:
      app: mcp-server
  template:
    metadata:
      labels:
        app: mcp-server
    spec:
      containers:
      - name: mcp-server
        image: slack-mcp-server:latest
        ports:
        - containerPort: 3001
        env:
        - name: SLACK_BOT_TOKEN
          valueFrom:
            secretKeyRef:
              name: slack-secrets
              key: bot-token
        envFrom:
        - configMapRef:
            name: mcp-server-config
        args:
        - "--transport"
        - "sse"
        - "--host"
        - "0.0.0.0"
        - "--port"
        - "3001"
```

## Security Best Practices

### Token Management

- **Never commit tokens to version control**
- **Use environment variables or secret management systems**
- **Rotate tokens regularly**
- **Use different tokens for different environments**

### Environment File Security

```bash
# Add to .gitignore
.env
.env.local
.env.production
.env.staging
*.env

# Set proper file permissions
chmod 600 .env.production
```

### Production Security

```bash
# .env.production (secure configuration)
SLACK_BOT_TOKEN=${SLACK_BOT_TOKEN}  # Use environment substitution
MCP_TRANSPORT=sse
MCP_HOST=0.0.0.0
MCP_PORT=3001
LOG_LEVEL=WARNING                   # Reduce log verbosity
MCP_TIMEOUT=60
MCP_MAX_RETRIES=5
```

## Troubleshooting Configuration

### Common Issues

#### 1. Invalid Bot Token

**Error**: `slack_sdk.errors.SlackApiError: invalid_auth`

**Solutions**:
```bash
# Check if token is set
echo $SLACK_BOT_TOKEN

# Verify token format (should start with xoxb-)
python -c "
import os
token = os.environ.get('SLACK_BOT_TOKEN', '')
if token.startswith('xoxb-'):
    print('✓ Token format is correct')
else:
    print('✗ Invalid token format')
"

# Test token with Slack API
curl -H "Authorization: Bearer $SLACK_BOT_TOKEN" \
     https://slack.com/api/auth.test

# Test MCP server startup (Method 1: Console Script)
slack-mcp-server --help

# Test MCP server startup (Method 2: Python Module)
python -m slack_mcp.mcp --help

# Test MCP server startup (Method 3: Poetry)
poetry run slack-mcp-server --help

# Test MCP server startup (Method 4: UV)
uv run slack-mcp-server --help
```

#### 2. Port Already in Use

**Error**: `OSError: [Errno 48] Address already in use`

**Solutions**:
```bash
# Find process using the port
lsof -i :3001

# Use a different port (Method 1: Console Script)
slack-mcp-server --transport sse --port 3002

# Use a different port (Method 2: Python Module)
python -m slack_mcp.mcp --transport sse --port 3002

# Use a different port (Method 3: Poetry)
poetry run slack-mcp-server --transport sse --port 3002

# Use a different port (Method 4: UV)
uv run slack-mcp-server --transport sse --port 3002

# Kill conflicting process
kill -9 <PID>
```

#### 3. Environment File Not Loading

**Error**: Configuration not being read from .env file

**Solutions**:
```bash
# Check if .env file exists
ls -la .env*

# Verify .env file format (no spaces around =)
# Correct:   KEY=value
# Incorrect: KEY = value

# Test environment loading
python -c "
from dotenv import load_dotenv
import os
load_dotenv()
print('SLACK_BOT_TOKEN:', 'SET' if os.environ.get('SLACK_BOT_TOKEN') else 'NOT SET')
"
```

## Configuration Reference

### Complete Environment Variables Reference

| Variable | Required | Default | Description |
|----------|----------|---------|-------------|
| `SLACK_BOT_TOKEN` | Yes | - | Slack bot token (xoxb-...) |
| `SLACK_TOKEN` | No | - | Alternative token variable |
| `SLACK_BOT_ID` | No | - | Slack bot ID |
| `SLACK_USER_TOKEN` | No | - | Slack user token (xoxp-...) |
| `SLACK_SIGNING_SECRET` | No | - | Slack signing secret for webhooks |
| `SLACK_TEST_CHANNEL` | No | - | Test channel name (#channel) |
| `SLACK_TEST_CHANNEL_ID` | No | - | Test channel ID (C1234567890) |
| `QUEUE_BACKEND` | No | `memory` | Queue backend type |
| `REDIS_URL` | No | - | Redis connection URL |
| `KAFKA_BOOTSTRAP` | No | - | Kafka bootstrap servers |

For additional deployment and architectural information, see [MCP Server Architecture](/dev/next/architecture/mcp-server-architecture).
