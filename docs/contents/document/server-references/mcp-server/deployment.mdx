---
id: mcp-server-deployment
title: Deployment
sidebar_position: 3
---

# MCP Server Deployment

This guide covers deployment strategies for the Slack MCP Server across different environments and platforms, with practical examples and best practices.

## Local Development Deployment

### Quick Start

```bash
# Clone the repository
git clone https://github.com/Chisanan232/slack-mcp-server.git
cd slack-mcp-server

# Install dependencies
pip install -e .

# Create environment file
cat > .env << EOF
SLACK_BOT_TOKEN=xoxb-your-development-token
QUEUE_BACKEND=memory
EOF

# Start the MCP server (Multiple execution methods)
# Method 1: Console Script (Recommended)
slack-mcp-server

# Method 2: Python Module
python -m slack_mcp.mcp

# Method 3: Poetry (if using Poetry)
poetry install
poetry run slack-mcp-server

# Method 4: UV (if using UV)
uv sync
uv run slack-mcp-server
```

### Development Environment Setup

Create a comprehensive development configuration:

```bash
# .env.development
SLACK_BOT_TOKEN=xoxb-your-development-token
SLACK_TEST_CHANNEL=#dev-testing
QUEUE_BACKEND=memory
```

Start the server with development settings:

```bash
# Method 1: Console Script (Recommended for development)
slack-mcp-server --log-level DEBUG

# Method 2: Python Module
python -m slack_mcp.mcp --log-level DEBUG

# Method 3: Poetry (Development workflow)
poetry run slack-mcp-server --log-level DEBUG

# Method 4: UV (Modern development)
uv run slack-mcp-server --log-level DEBUG
```

## Docker Deployment

### Basic Docker Setup

Create a `Dockerfile` for the MCP server:

```dockerfile
FROM python:3.11-slim

# Set working directory
WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y \
    curl \
    && rm -rf /var/lib/apt/lists/*

# Copy requirements and install Python dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY . .

# Set environment variables
ENV QUEUE_BACKEND=memory

# Expose port (for HTTP transports only)
EXPOSE 3001

# Install slack-mcp-server package
RUN pip install -e .

# Run the application (stdio transport by default)
CMD ["slack-mcp-server"]
```

Build and run the Docker container:

```bash
# Build the image
docker build -t slack-mcp-server .

# Run with environment file
docker run -d \
  --name mcp-server \
  --env-file .env.production \
  -p 3001:3001 \
  slack-mcp-server

# Run with environment variables
docker run -d \
  --name mcp-server \
  -e SLACK_BOT_TOKEN=xoxb-your-token \
  -e QUEUE_BACKEND=memory \
  -p 3001:3001 \
  slack-mcp-server
```

### Docker Compose Deployment

Create a `docker-compose.yml` file:

```yaml
version: '3.8'

services:
  mcp-server:
    build: .
    container_name: slack-mcp-server
    ports:
      - "3001:3001"
    env_file:
      - .env.production
    environment:
      - QUEUE_BACKEND=memory
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3001/mcp"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    volumes:
      - ./logs:/app/logs
    networks:
      - mcp-network

  # Optional: Reverse proxy
  nginx:
    image: nginx:alpine
    container_name: mcp-nginx
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl
    depends_on:
      - mcp-server
    networks:
      - mcp-network

networks:
  mcp-network:
    driver: bridge
```

Deploy with Docker Compose:

```bash
# Start services
docker-compose up -d

# View logs
docker-compose logs -f mcp-server

# Scale the service
docker-compose up -d --scale mcp-server=3

# Stop services
docker-compose down
```

## Kubernetes Deployment

### ConfigMap and Secrets

Create configuration resources:

```yaml
# mcp-configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: mcp-server-config
  namespace: default
data:
  MCP_TRANSPORT: "sse"
  MCP_HOST: "0.0.0.0"
  MCP_PORT: "3001"
  MCP_MOUNT_PATH: "/mcp"
  LOG_LEVEL: "INFO"
  MCP_TIMEOUT: "60"
  MCP_MAX_RETRIES: "5"

---
# mcp-secrets.yaml
apiVersion: v1
kind: Secret
metadata:
  name: mcp-server-secrets
  namespace: default
type: Opaque
data:
  # Base64 encoded slack bot token
  SLACK_BOT_TOKEN: eG94Yi15b3VyLWJvdC10b2tlbi1oZXJl
```

### Deployment Configuration

```yaml
# mcp-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mcp-server
  namespace: default
  labels:
    app: mcp-server
spec:
  replicas: 3
  selector:
    matchLabels:
      app: mcp-server
  template:
    metadata:
      labels:
        app: mcp-server
    spec:
      containers:
      - name: mcp-server
        image: slack-mcp-server:latest
        ports:
        - containerPort: 3001
          name: http
        env:
        - name: SLACK_BOT_TOKEN
          valueFrom:
            secretKeyRef:
              name: mcp-server-secrets
              key: SLACK_BOT_TOKEN
        envFrom:
        - configMapRef:
            name: mcp-server-config
        args:
        - "--transport"
        - "sse"
        - "--host"
        - "0.0.0.0"
        - "--port"
        - "3001"
        resources:
          requests:
            memory: "256Mi"
            cpu: "200m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /mcp
            port: 3001
          initialDelaySeconds: 30
          periodSeconds: 30
        readinessProbe:
          httpGet:
            path: /mcp
            port: 3001
          initialDelaySeconds: 10
          periodSeconds: 10
```

### Service and Ingress

```yaml
# mcp-service.yaml
apiVersion: v1
kind: Service
metadata:
  name: mcp-server-service
  namespace: default
spec:
  selector:
    app: mcp-server
  ports:
  - name: http
    protocol: TCP
    port: 80
    targetPort: 3001
  type: ClusterIP

---
# mcp-ingress.yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: mcp-server-ingress
  namespace: default
  annotations:
    kubernetes.io/ingress.class: "nginx"
    cert-manager.io/cluster-issuer: "letsencrypt"
    nginx.ingress.kubernetes.io/rewrite-target: /
spec:
  tls:
  - hosts:
    - mcp.yourdomain.com
    secretName: mcp-tls
  rules:
  - host: mcp.yourdomain.com
    http:
      paths:
      - path: /mcp
        pathType: Prefix
        backend:
          service:
            name: mcp-server-service
            port:
              number: 80
```

Deploy to Kubernetes:

```bash
# Apply configurations
kubectl apply -f mcp-configmap.yaml
kubectl apply -f mcp-deployment.yaml
kubectl apply -f mcp-service.yaml
kubectl apply -f mcp-ingress.yaml

# Check deployment status
kubectl get pods -l app=mcp-server
kubectl get services
kubectl get ingress

# View logs
kubectl logs -l app=mcp-server -f

# Scale deployment
kubectl scale deployment mcp-server --replicas=5
```

## Cloud Platform Deployments

### Heroku Deployment

Create a `Procfile`:

```
web: python -m slack_mcp.mcp --transport sse --host 0.0.0.0 --port $PORT
```

Create `runtime.txt`:

```
python-3.11.5
```

Deploy to Heroku:

```bash
# Install Heroku CLI and login
heroku login

# Create application
heroku create your-mcp-server-app

# Set environment variables
heroku config:set SLACK_BOT_TOKEN="xoxb-your-token"
heroku config:set MCP_TRANSPORT="sse"
heroku config:set LOG_LEVEL="INFO"

# Deploy
git push heroku main

# View logs
heroku logs --tail

# Scale dynos
heroku ps:scale web=2
```

### Google Cloud Run

Create `cloudbuild.yaml`:

```yaml
steps:
- name: 'gcr.io/cloud-builders/docker'
  args: ['build', '-t', 'gcr.io/$PROJECT_ID/mcp-server', '.']
- name: 'gcr.io/cloud-builders/docker'
  args: ['push', 'gcr.io/$PROJECT_ID/mcp-server']
- name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
  entrypoint: gcloud
  args:
  - 'run'
  - 'deploy'
  - 'mcp-server'
  - '--image'
  - 'gcr.io/$PROJECT_ID/mcp-server'
  - '--region'
  - 'us-central1'
  - '--allow-unauthenticated'
  - '--set-env-vars'
  - 'MCP_TRANSPORT=sse,LOG_LEVEL=INFO'
```

Deploy to Cloud Run:

```bash
# Set project
gcloud config set project YOUR_PROJECT_ID

# Build and deploy
gcloud builds submit --config cloudbuild.yaml

# Update service with secrets
gcloud run services update mcp-server \
  --region us-central1 \
  --set-env-vars "MCP_TRANSPORT=sse" \
  --set-secrets "SLACK_BOT_TOKEN=slack-bot-token:latest"
```

### AWS ECS Deployment

Create task definition (`task-definition.json`):

```json
{
  "family": "mcp-server",
  "networkMode": "awsvpc",
  "requiresCompatibilities": ["FARGATE"],
  "cpu": "256",
  "memory": "512",
  "executionRoleArn": "arn:aws:iam::ACCOUNT:role/ecsTaskExecutionRole",
  "containerDefinitions": [
    {
      "name": "mcp-server",
      "image": "your-account.dkr.ecr.region.amazonaws.com/mcp-server:latest",
      "portMappings": [
        {
          "containerPort": 3001,
          "protocol": "tcp"
        }
      ],
      "environment": [
        {
          "name": "MCP_TRANSPORT",
          "value": "sse"
        },
        {
          "name": "MCP_HOST",
          "value": "0.0.0.0"
        },
        {
          "name": "MCP_PORT",
          "value": "3001"
        },
        {
          "name": "LOG_LEVEL",
          "value": "INFO"
        }
      ],
      "secrets": [
        {
          "name": "SLACK_BOT_TOKEN",
          "valueFrom": "arn:aws:secretsmanager:region:account:secret:slack-bot-token"
        }
      ],
      "logConfiguration": {
        "logDriver": "awslogs",
        "options": {
          "awslogs-group": "/ecs/mcp-server",
          "awslogs-region": "us-west-2",
          "awslogs-stream-prefix": "ecs"
        }
      }
    }
  ]
}
```

## Production Deployment Best Practices

### Security Configuration

```bash
# .env.production (secure)
SLACK_BOT_TOKEN=${SLACK_BOT_TOKEN}  # Use environment substitution
MCP_TRANSPORT=sse
MCP_HOST=0.0.0.0
MCP_PORT=3001
LOG_LEVEL=WARNING                   # Reduce log verbosity
MCP_TIMEOUT=60
MCP_MAX_RETRIES=5
```

### Monitoring and Logging

#### Application Logging

```python
# Custom logging configuration
import logging
import sys

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(sys.stdout),
        logging.FileHandler('/app/logs/mcp-server.log')
    ]
)
```

#### Health Checks

```bash
# Health check script
#!/bin/bash
# health-check.sh

HEALTH_URL="http://localhost:3001/mcp"
TIMEOUT=10

response=$(curl -s -o /dev/null -w "%{http_code}" --max-time $TIMEOUT $HEALTH_URL)

if [ $response -eq 200 ]; then
    echo "Health check passed"
    exit 0
else
    echo "Health check failed with status: $response"
    exit 1
fi
```

### Performance Optimization

#### Resource Limits

```yaml
# Kubernetes resource limits
resources:
  requests:
    memory: "256Mi"
    cpu: "200m"
  limits:
    memory: "512Mi"
    cpu: "500m"
```

#### Connection Pooling

Configure optimal connection settings:

```bash
# Environment variables for performance
MCP_TIMEOUT=60
MCP_MAX_RETRIES=5
SLACK_CLIENT_TIMEOUT=30
```

### Backup and Recovery

#### Configuration Backup

```bash
#!/bin/bash
# backup-config.sh

BACKUP_DIR="/backups/$(date +%Y%m%d_%H%M%S)"
mkdir -p $BACKUP_DIR

# Backup environment files
cp .env* $BACKUP_DIR/

# Backup Kubernetes configurations
kubectl get configmap mcp-server-config -o yaml > $BACKUP_DIR/configmap.yaml
kubectl get secret mcp-server-secrets -o yaml > $BACKUP_DIR/secrets.yaml

echo "Backup completed in $BACKUP_DIR"
```

### Deployment Validation

#### Pre-deployment Checks

```bash
#!/bin/bash
# validate-deployment.sh

echo "üîç Validating deployment configuration..."

# Check required environment variables
if [ -z "$SLACK_BOT_TOKEN" ]; then
    echo "‚ùå SLACK_BOT_TOKEN not set"
    exit 1
fi

# Test Slack API connectivity
python -c "
from slack_sdk import WebClient
import os

client = WebClient(token=os.environ['SLACK_BOT_TOKEN'])
try:
    response = client.auth_test()
    print('‚úÖ Slack API connection successful')
    print(f'   Team: {response[\"team\"]}')
    print(f'   User: {response[\"user\"]}')
except Exception as e:
    print(f'‚ùå Slack API connection failed: {e}')
    exit(1)
"

# Validate configuration
python -m slack_mcp.mcp --help > /dev/null 2>&1
if [ $? -eq 0 ]; then
    echo "‚úÖ MCP server configuration valid"
else
    echo "‚ùå MCP server configuration invalid"
    exit 1
fi

echo "‚úÖ All deployment validations passed"
```

#### Post-deployment Tests

```bash
#!/bin/bash
# test-deployment.sh

SERVER_URL="http://localhost:3001"
TIMEOUT=30

echo "üß™ Testing MCP server deployment..."

# Test health endpoint
if curl -f -s --max-time $TIMEOUT "$SERVER_URL/mcp" > /dev/null; then
    echo "‚úÖ Health check endpoint accessible"
else
    echo "‚ùå Health check endpoint failed"
    exit 1
fi

# Test MCP functionality
python -c "
import requests
import sys

try:
    response = requests.get('$SERVER_URL/mcp', timeout=$TIMEOUT)
    if response.status_code == 200:
        print('‚úÖ MCP server responding correctly')
    else:
        print(f'‚ùå MCP server returned status {response.status_code}')
        sys.exit(1)
except Exception as e:
    print(f'‚ùå MCP server connection failed: {e}')
    sys.exit(1)
"

echo "‚úÖ All deployment tests passed"
```

## Troubleshooting Deployments

### Common Deployment Issues

#### Container Startup Issues

```bash
# Check container logs
docker logs mcp-server

# Check container resource usage
docker stats mcp-server

# Inspect container configuration
docker inspect mcp-server
```

#### Kubernetes Pod Issues

```bash
# Check pod status
kubectl describe pod <pod-name>

# View pod logs
kubectl logs <pod-name> -f

# Check resource usage
kubectl top pods
```

#### Network Connectivity Issues

```bash
# Test network connectivity
kubectl exec -it <pod-name> -- curl -v http://localhost:3001/mcp

# Check service endpoints
kubectl get endpoints mcp-server-service

# Test DNS resolution
kubectl exec -it <pod-name> -- nslookup mcp-server-service
```

For additional configuration details, see [MCP Server Configuration](./configuration.mdx).
